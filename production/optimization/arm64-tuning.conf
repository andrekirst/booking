# ARM64 Performance Tuning Configuration für Raspberry Pi Zero 2 W
# Optimiert für ARM Cortex-A53 Quad-Core @ 1GHz mit 512MB RAM

# =============================================================================
# KERNEL PARAMETERS (/etc/sysctl.conf additions)
# =============================================================================

# Memory Management - Optimiert für 512MB RAM
vm.swappiness=10                    # Minimal swapping (default: 60)
vm.vfs_cache_pressure=50            # Favor inode/dentry cache (default: 100)
vm.dirty_background_ratio=5         # Start background writeback at 5% (default: 10%)
vm.dirty_ratio=10                   # Force writeback at 10% (default: 20%)
vm.dirty_writeback_centisecs=1500   # Writeback interval (default: 500)
vm.dirty_expire_centisecs=3000      # Dirty page expiration (default: 3000)
vm.min_free_kbytes=16384           # Reserve 16MB for kernel (default: varies)
vm.overcommit_memory=1             # Allow memory overcommit
vm.overcommit_ratio=50             # Conservative overcommit

# CPU Scheduler - ARM Cortex-A53 Optimization
kernel.sched_migration_cost_ns=500000      # Reduce task migration
kernel.sched_min_granularity_ns=10000000   # 10ms minimum slice
kernel.sched_wakeup_granularity_ns=15000000 # 15ms wakeup granularity
kernel.sched_latency_ns=24000000           # 24ms for 4 cores
kernel.sched_rt_runtime_us=950000          # Real-time budget
kernel.sched_rt_period_us=1000000          # Real-time period

# Network Stack - Optimiert für geringe Bandbreite
net.core.rmem_default=262144        # Default receive buffer
net.core.rmem_max=16777216         # Max receive buffer (16MB)
net.core.wmem_default=262144        # Default send buffer  
net.core.wmem_max=16777216         # Max send buffer (16MB)
net.core.netdev_max_backlog=2500   # Network device backlog
net.core.somaxconn=2048            # Socket listen backlog

# TCP Stack - ARM64 specific tuning
net.ipv4.tcp_rmem=4096 65536 16777216     # TCP receive window
net.ipv4.tcp_wmem=4096 65536 16777216     # TCP send window
net.ipv4.tcp_congestion_control=bbr       # BBR congestion control
net.ipv4.tcp_slow_start_after_idle=0      # Disable slow start after idle
net.ipv4.tcp_tw_reuse=1                   # Reuse TIME_WAIT sockets
net.ipv4.tcp_fin_timeout=30               # FIN timeout (default: 60)
net.ipv4.tcp_keepalive_time=1200          # Keepalive time (default: 7200)
net.ipv4.tcp_keepalive_probes=9           # Keepalive probes
net.ipv4.tcp_keepalive_intvl=75           # Keepalive interval

# File System - SD Card optimization
vm.dirty_bytes=33554432            # 32MB dirty limit
vm.dirty_background_bytes=16777216  # 16MB background limit

# Security - Hardening
kernel.kptr_restrict=2             # Hide kernel pointers
kernel.dmesg_restrict=1            # Restrict dmesg access
kernel.yama.ptrace_scope=1         # Restrict ptrace
net.ipv4.conf.all.rp_filter=1     # Reverse path filtering
net.ipv4.conf.default.rp_filter=1
net.ipv4.conf.all.accept_source_route=0  # Disable source routing
net.ipv4.conf.default.accept_source_route=0
net.ipv4.conf.all.accept_redirects=0     # Disable ICMP redirects
net.ipv4.conf.default.accept_redirects=0
net.ipv4.conf.all.send_redirects=0       # Don't send redirects
net.ipv4.conf.default.send_redirects=0
net.ipv4.icmp_echo_ignore_broadcasts=1   # Ignore ping broadcasts
net.ipv4.icmp_ignore_bogus_error_responses=1

# =============================================================================
# SYSTEMD SERVICE OPTIMIZATIONS
# =============================================================================

# Docker Service Override (/etc/systemd/system/docker.service.d/pi-zero.conf)
[Service]
# Resource limits for Pi Zero 2 W
MemoryLimit=400M
CPUQuota=350%
LimitNOFILE=65536
LimitNPROC=4096

# Nice priority (lower = higher priority)
Nice=-5

# OOM adjustment (less likely to be killed)
OOMScoreAdjust=-500

# IO scheduling class (1=real-time, 2=best-effort, 3=idle)
IOSchedulingClass=2
IOSchedulingPriority=4

# CPU affinity - use cores 0,1,2 (reserve core 3 for system)
CPUAffinity=0 1 2

# =============================================================================
# POSTGRESQL OPTIMIZATIONS für ARM64
# =============================================================================

# Connection and Authentication
max_connections = 20                    # Reduced for Pi Zero
shared_buffers = 32MB                   # 8% of 400MB available RAM
huge_pages = off                        # Not available on Pi Zero

# Memory Settings
work_mem = 2MB                          # Per-operation memory
maintenance_work_mem = 8MB              # Maintenance operations
effective_cache_size = 128MB            # OS cache estimate
random_page_cost = 1.1                  # SSD-optimized
seq_page_cost = 1.0                     # Sequential read cost

# Checkpoint and WAL
checkpoint_completion_target = 0.9      # Spread checkpoints
wal_buffers = 1MB                       # WAL buffer size
max_wal_size = 128MB                    # Maximum WAL size
min_wal_size = 64MB                     # Minimum WAL size

# Background Writer - ARM optimization
bgwriter_delay = 200ms                  # Background writer delay
bgwriter_lru_maxpages = 100            # Max pages per round
bgwriter_lru_multiplier = 2.0          # LRU multiplier

# Vacuum and Autovacuum
autovacuum_max_workers = 2              # Reduced for Pi Zero
autovacuum_vacuum_cost_delay = 2ms      # Throttle vacuum I/O

# =============================================================================
# .NET RUNTIME OPTIMIZATIONS
# =============================================================================

# Environment Variables für .NET auf ARM64
DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1    # Invariant globalization
DOTNET_RUNNING_IN_CONTAINER=1               # Container optimizations
DOTNET_USE_POLLING_FILE_WATCHER=1           # Polling instead of inotify
DOTNET_HOSTBUILDER_RELOADCONFIGONCHANGE=0   # Disable config reload

# Garbage Collection - Pi Zero specific
DOTNET_gcServer=0                           # Workstation GC
DOTNET_GCHeapCount=2                        # 2 heaps for 4 cores
DOTNET_GCLOHThreshold=10000                 # Large object threshold
DOTNET_GCLatencyMode=SustainedLowLatency    # Low latency mode
DOTNET_GCConserveMemory=9                   # Maximum memory conservation
DOTNET_GCHeapAffinitizeMask=0x7             # Use cores 0,1,2

# Thread Pool - ARM Cortex-A53 tuning
DOTNET_ThreadPool_UnfairSemaphoreSpinLimit=0          # No spinning
DOTNET_ThreadPool_UsePortableThreadPoolGrowth=0       # Faster growth
DOTNET_ThreadPool_MinWorkerThreads=4                  # Min worker threads
DOTNET_ThreadPool_MaxWorkerThreads=16                 # Max worker threads

# JIT Compilation
DOTNET_TieredCompilation=1                  # Enable tiered compilation
DOTNET_TC_QuickJitForLoops=1               # Quick JIT for loops
DOTNET_ReadyToRun=1                         # Enable ReadyToRun

# =============================================================================
# NGINX OPTIMIZATIONS für ARM64
# =============================================================================

# Worker processes and connections
worker_processes 2;                         # 2 workers for 4 cores
worker_cpu_affinity 01 10;                 # Pin to cores 0,1
worker_connections 512;                     # Reduced for Pi Zero
worker_rlimit_nofile 2048;                 # File descriptor limit

# Event handling
use epoll;                                  # Linux epoll
accept_mutex on;                            # Serialize accept
accept_mutex_delay 100ms;                   # Mutex delay
multi_accept on;                            # Accept multiple connections

# Buffer sizes - ARM64 cache line optimization  
client_body_buffer_size 64k;               # 64KB aligned
client_header_buffer_size 1k;              # Small headers
large_client_header_buffers 4 4k;          # Large header buffers
output_buffers 2 32k;                      # Output buffers

# Timeouts - optimized for Pi Zero performance
client_body_timeout 30s;                   # Body timeout
client_header_timeout 30s;                 # Header timeout
keepalive_timeout 30s;                     # Keepalive timeout
keepalive_requests 30;                     # Requests per keepalive
send_timeout 30s;                          # Send timeout

# Compression - balance between CPU and bandwidth
gzip_comp_level 4;                         # Moderate compression
gzip_min_length 1000;                      # Min compress size
gzip_vary on;                              # Vary header

# =============================================================================
# DOCKER CONTAINER OPTIMIZATIONS
# =============================================================================

# Container resource limits für Pi Zero 2 W
# Backend (.NET):   75MB RAM, 0.8 CPU
# Frontend (Nginx): 40MB RAM, 0.3 CPU  
# Database (PG):    80MB RAM, 0.6 CPU
# Monitoring:       60MB RAM, 0.3 CPU
# Total:           255MB RAM, 2.0 CPU

# Memory limits with OOM kill protection
--memory=75m --memory-swap=150m --oom-kill-disable=false

# CPU limits with proper scheduling
--cpus=0.8 --cpu-period=100000 --cpu-quota=80000

# IO limits für SD Card protection
--device-read-bps=/dev/mmcblk0:10mb
--device-write-bps=/dev/mmcblk0:5mb

# Network optimizations
--network-opt com.docker.network.driver.mtu=1450

# =============================================================================
# ARM64 COMPILER OPTIMIZATIONS
# =============================================================================

# GCC/Clang flags für ARM Cortex-A53
-march=armv8-a+crc                         # ARM v8-A with CRC extension
-mtune=cortex-a53                          # Tune for Cortex-A53
-mfix-cortex-a53-835769                    # Fix known ARM erratum
-mfix-cortex-a53-843419                    # Fix another erratum
-O2                                        # Optimization level 2
-ffast-math                                # Fast math operations
-funroll-loops                             # Loop unrolling
-fomit-frame-pointer                       # Omit frame pointer
-pipe                                      # Use pipes

# Link-time optimizations
-flto                                      # Link-time optimization
-Wl,--gc-sections                          # Garbage collect sections
-Wl,--strip-all                           # Strip all symbols

# =============================================================================
# RASPBERRY PI SPECIFIC OPTIMIZATIONS
# =============================================================================

# GPU Memory Split (for headless server)
gpu_mem=16                                 # Minimal GPU memory

# CPU Governor
scaling_governor=ondemand                  # Dynamic CPU scaling

# Disable unused interfaces
dtoverlay=disable-bt                       # Disable Bluetooth
dtoverlay=disable-wifi                     # Disable WiFi (if using Ethernet)

# Enable hardware random number generator
dtparam=random=on

# Optimize SD card performance
dtparam=sd_overclock=100                   # Overclock SD interface
dtparam=sd_force_pio=0                     # Use DMA for SD

# =============================================================================
# MONITORING AND PROFILING
# =============================================================================

# Perf events für ARM64 profiling
echo 1 > /proc/sys/kernel/perf_event_paranoid
echo 0 > /proc/sys/kernel/kptr_restrict

# CPU frequency monitoring
cat > /etc/systemd/system/cpu-freq-monitor.service << 'EOF'
[Unit]
Description=CPU Frequency Monitor
After=multi-user.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'while true; do echo "$(date): $(cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq)" >> /var/log/cpu-freq.log; sleep 60; done'
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# =============================================================================
# PERFORMANCE VERIFICATION COMMANDS
# =============================================================================

# System performance check script
cat > /opt/booking/scripts/perf-check.sh << 'EOF'
#!/bin/bash
echo "=== ARM64 Performance Check ==="
echo "CPU Info:"
lscpu | grep -E "(Architecture|CPU op-mode|Thread|Core|Socket|Model name|CPU MHz)"
echo
echo "Memory Info:"
free -h
echo
echo "CPU Frequency:"
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq 2>/dev/null | head -4
echo
echo "Thermal Status:"
vcgencmd measure_temp 2>/dev/null || echo "vcgencmd not available"
echo
echo "Load Average:"
uptime
echo
echo "Docker Stats:"
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" 2>/dev/null || echo "Docker not running"
EOF

chmod +x /opt/booking/scripts/perf-check.sh

# =============================================================================
# BENCHMARK SCRIPT für ARM64 Performance Testing
# =============================================================================

cat > /opt/booking/scripts/arm64-benchmark.sh << 'EOF'
#!/bin/bash
# ARM64 Performance Benchmark für Pi Zero 2 W

echo "ARM64 Performance Benchmark - Raspberry Pi Zero 2 W"
echo "=================================================="

# CPU Benchmark
echo "CPU Integer Performance:"
time echo 'scale=5000; 4*a(1)' | bc -l >/dev/null

# Memory Bandwidth Test
echo "Memory Bandwidth:"
dd if=/dev/zero of=/dev/null bs=1M count=100 2>&1 | grep copied

# Disk I/O Test (SD Card)
echo "Disk I/O Performance:"
dd if=/dev/zero of=/tmp/test_io bs=1M count=10 oflag=direct 2>&1 | grep copied
rm /tmp/test_io

# Network Test (if applicable)
echo "Network Latency (localhost):"
ping -c 4 localhost | tail -1

# Docker Performance
if command -v docker >/dev/null; then
    echo "Docker Performance:"
    time docker run --rm alpine:latest echo "Docker container startup test" >/dev/null
fi

echo "Benchmark completed."
EOF

chmod +x /opt/booking/scripts/arm64-benchmark.sh